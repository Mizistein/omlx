{% extends "base.html" %}

{% block title %}Chat - oMLX Admin{% endblock %}

{% block head %}
<!-- Markdown rendering -->
<script src="/admin/static/js/marked.umd.js"></script>
<script src="/admin/static/js/marked-highlight.umd.js"></script>

<!-- Code highlighting -->
<link rel="stylesheet" id="hljs-light-theme" href="/admin/static/css/hljs-github.min.css">
<link rel="stylesheet" id="hljs-dark-theme" href="/admin/static/css/hljs-github-dark.min.css" disabled>
<script src="/admin/static/js/highlight.min.js"></script>
<script src="/admin/static/js/hljs-python.min.js"></script>
<script src="/admin/static/js/hljs-javascript.min.js"></script>
<script src="/admin/static/js/hljs-bash.min.js"></script>
<script src="/admin/static/js/hljs-json.min.js"></script>

<!-- Math rendering with KaTeX -->
<link rel="stylesheet" href="/admin/static/css/katex.min.css">
<script defer src="/admin/static/js/katex.min.js"></script>
<script defer src="/admin/static/js/katex-auto-render.min.js"></script>

<style>
    /* CSS Variables for theming */
    :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8fafc;
        --bg-tertiary: #f1f5f9;
        --text-primary: #0f172a;
        --text-secondary: #475569;
        --text-tertiary: #64748b;
        --text-muted: #94a3b8;
        --border-faint: #e2e8f0;
        --border-normal: #cbd5e1;
        --code-bg: #f3f4f6;
    }

    [data-theme="dark"] {
        --bg-primary: #1d1d20;
        --bg-secondary: #252529;
        --bg-tertiary: #2d2d32;
        --text-primary: #efefef;
        --text-secondary: #a1a1aa;
        --text-tertiary: #71717a;
        --text-muted: #52525b;
        --border-faint: #3f3f46;
        --border-normal: #52525b;
        --code-bg: #27272a;
    }

    body {
        background-color: var(--bg-primary) !important;
        color: var(--text-primary);
    }


    .bg-surface-primary { background-color: var(--bg-primary) !important; }
    .bg-surface-secondary { background-color: var(--bg-secondary) !important; }
    .text-text-primary { color: var(--text-primary) !important; }
    .text-text-secondary { color: var(--text-secondary) !important; }
    .text-text-tertiary { color: var(--text-tertiary) !important; }
    .border-border-faint { border-color: var(--border-faint) !important; }

    /* Scrollbar */
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--border-normal); border-radius: 3px; }

    /* Sidebar */
    .sidebar-width { width: 260px; min-width: 260px; }
    .sidebar-hidden { width: 0 !important; min-width: 0 !important; overflow: hidden; }
    .sidebar-transition { transition: all 0.25s ease; }

    /* Messages */
    .message-fade-in { animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

    .assistant-message {
        background: var(--bg-primary);
        border: 1px solid var(--border-faint);
        border-radius: 16px;
        max-width: 768px;
    }

    .message-header {
        padding: 8px 12px;
        border-bottom: 1px solid var(--border-faint);
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: var(--text-primary);
    }
    .message-header svg {
        color: var(--text-tertiary);
    }

    .message-body {
        padding: 12px;
        font-size: 14px;
        line-height: 1.6;
        color: var(--text-primary);
    }

    .user-message {
        max-width: min(768px, 100%);
        align-self: flex-end;
    }

    .user-message-bubble {
        background: var(--bg-secondary);
        border-radius: 24px;
        padding: 8px 16px;
        font-size: 14px;
        color: var(--text-primary);
    }
    .user-message-bubble p {
        color: var(--text-primary) !important;
        margin: 0;
    }
    .user-message-bubble * {
        color: var(--text-primary);
    }

    /* Loading dots */
    .loading-dots { display: flex; gap: 4px; align-items: center; }
    .loading-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--text-muted); animation: pulse 1.4s infinite; }
    .loading-dot:nth-child(2) { animation-delay: 0.2s; }
    .loading-dot:nth-child(3) { animation-delay: 0.4s; }
    @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

    /* Markdown content */
    .markdown-content { line-height: 1.6; color: var(--text-primary); }
    .markdown-content h1, .markdown-content h2, .markdown-content h3 { font-weight: 600; margin-top: 1.5em; margin-bottom: 0.5em; color: var(--text-primary); }
    .markdown-content h1 { font-size: 1.5em; }
    .markdown-content h2 { font-size: 1.3em; }
    .markdown-content h3 { font-size: 1.1em; }
    .markdown-content p { margin-bottom: 1em; color: var(--text-primary); }
    .markdown-content ul, .markdown-content ol { margin-bottom: 1em; padding-left: 1.5em; color: var(--text-primary); }
    .markdown-content li { margin-bottom: 0.25em; color: var(--text-primary); }
    .markdown-content code { background-color: var(--code-bg); padding: 0.125em 0.25em; border-radius: 0.25em; font-size: 0.875em; color: var(--text-primary); }
    .markdown-content pre { background-color: var(--code-bg); border-radius: 0.5em; padding: 1em; margin: 1em 0; overflow-x: auto; }
    .markdown-content pre code { background: none; padding: 0; color: var(--text-primary); }

    /* Code block copy button */
    .code-block-wrapper { position: relative; }
    .code-copy-btn {
        position: absolute; top: 0.5em; right: 0.5em;
        background: var(--bg-secondary); border: 1px solid var(--border-faint);
        border-radius: 0.375em; padding: 0.25em 0.5em; font-size: 0.7em; cursor: pointer;
        opacity: 0; transition: opacity 0.2s; color: var(--text-secondary);
    }
    .code-block-wrapper:hover .code-copy-btn { opacity: 1; }
    .code-copy-btn:hover { background: var(--bg-tertiary); }

    /* User message edit button */
    .user-message { position: relative; }
    .user-edit-btn {
        position: absolute; left: -32px; top: 50%; transform: translateY(-50%);
        width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;
        border-radius: 6px; border: none; background: transparent; color: var(--text-tertiary);
        cursor: pointer; transition: all 0.15s; opacity: 0;
    }
    .user-message:hover .user-edit-btn { opacity: 1; }
    .user-edit-btn:hover { background: var(--bg-secondary); color: var(--text-secondary); }

    /* Inline edit */
    .inline-edit-textarea {
        width: 100%; min-width: 280px; max-width: 600px;
        min-height: 80px; max-height: 300px; resize: vertical;
        padding: 12px 16px; border: 2px solid #2d3748; border-radius: 16px;
        background: var(--bg-primary); color: var(--text-primary);
        font-family: inherit; font-size: 14px; line-height: 1.6; outline: none;
    }
    .inline-edit-actions { display: flex; gap: 8px; margin-top: 8px; justify-content: flex-end; }

    /* Thinking container */
    .thinking-container {
        background: var(--bg-secondary);
        border: 1px solid var(--border-faint);
        border-radius: 0.75rem;
        margin: 0.5em 0;
        overflow: hidden;
    }
    .thinking-header {
        display: flex;
        align-items: center;
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        font-size: 0.75rem;
        color: var(--text-tertiary);
        gap: 0.5rem;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border-faint);
    }
    .thinking-header:hover {
        background: var(--bg-tertiary);
    }
    .thinking-icon {
        width: 14px;
        height: 14px;
        flex-shrink: 0;
    }
    .thinking-text {
        flex: 1;
        font-weight: 400;
    }
    .thinking-toggle {
        width: 14px;
        height: 14px;
        transition: transform 0.2s ease;
        transform: rotate(180deg);
    }
    .thinking-toggle.collapsed {
        transform: rotate(0deg);
    }
    .thinking-content {
        padding: 1rem;
        font-size: 0.8125rem;
        line-height: 1.6;
        color: var(--text-secondary);
        background: var(--bg-secondary);
        max-height: 400px;
        overflow-y: auto;
    }
    .thinking-content.collapsed { display: none; }

    /* Input area */
    .input-container {
        border: 1px solid var(--border-normal);
        border-radius: 1.5rem;
        background: var(--bg-primary);
        transition: border-color 0.2s;
    }
    .input-container:focus-within {
        border-color: var(--text-tertiary);
    }
    .input-container textarea {
        box-shadow: none !important;
    }
    .input-container textarea:focus {
        box-shadow: none !important;
    }
    .input-container textarea::placeholder {
        color: var(--text-muted);
    }

    /* API Key Modal */
    .api-key-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }
    .api-key-modal.hidden { display: none; }
    .api-key-modal-content {
        background: var(--bg-primary);
        border-radius: 1rem;
        padding: 2rem;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
    }

    /* Button styles */
    .btn-primary {
        background: #18181b;
        color: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.75rem;
        font-weight: 500;
        transition: all 0.2s;
    }
    .btn-primary:hover { background: #27272a; }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

    .message-action-btn {
        width: 28px; height: 28px;
        display: flex; align-items: center; justify-content: center;
        border-radius: 6px; border: none;
        background: transparent; color: var(--text-tertiary);
        cursor: pointer; transition: all 0.15s;
    }
    .message-action-btn:hover { background: var(--bg-secondary); color: var(--text-secondary); }
    .message-action-btn svg { color: inherit; }

    /* Dark mode adjustments */
    [data-theme="dark"] .hover\:bg-neutral-100:hover { background: var(--bg-tertiary) !important; }
    [data-theme="dark"] .bg-neutral-100 { background: var(--bg-tertiary) !important; }
    [data-theme="dark"] .hover\:bg-neutral-200:hover { background: var(--bg-secondary) !important; }
    [data-theme="dark"] .hover\:bg-neutral-800:hover { background: #3f3f46 !important; }
    [data-theme="dark"] .hover\:bg-red-100:hover { background: rgba(239, 68, 68, 0.2) !important; }
    [data-theme="dark"] .hover\:bg-red-50:hover { background: rgba(239, 68, 68, 0.15) !important; }
    [data-theme="dark"] .bg-neutral-50 { background: var(--bg-secondary) !important; }
    [data-theme="dark"] .bg-neutral-900 { background: #e5e5e5 !important; }
    [data-theme="dark"] .bg-white { background: var(--bg-primary) !important; }
    [data-theme="dark"] .border-neutral-200 { border-color: var(--border-faint) !important; }
    [data-theme="dark"] .text-neutral-400 { color: var(--text-muted) !important; }
    [data-theme="dark"] .text-neutral-500 { color: var(--text-tertiary) !important; }
    [data-theme="dark"] .text-neutral-600 { color: var(--text-secondary) !important; }
    [data-theme="dark"] .text-white { color: #18181b !important; }
    [data-theme="dark"] .user-message-bubble { background: var(--bg-tertiary) !important; }
    [data-theme="dark"] .focus\:ring-neutral-900:focus { --tw-ring-color: var(--border-normal) !important; }
    [data-theme="dark"] .text-xl, [data-theme="dark"] .text-2xl { color: var(--text-primary) !important; }
    [data-theme="dark"] .font-semibold, [data-theme="dark"] .font-bold, [data-theme="dark"] .font-medium { color: var(--text-primary); }
    [data-theme="dark"] .text-sm { color: var(--text-primary); }
    [data-theme="dark"] .text-red-500 { color: #f87171 !important; }
    [data-theme="dark"] .text-red-600 { color: #ef4444 !important; }
    [data-theme="dark"] .disabled\:bg-neutral-300:disabled { background: var(--bg-tertiary) !important; }
    [data-theme="dark"] .sidebar-width span { color: var(--text-primary); }
    [data-theme="dark"] .sidebar-width .text-neutral-600 { color: var(--text-secondary) !important; }
    [data-theme="dark"] .sidebar-width .text-neutral-500 { color: var(--text-tertiary) !important; }
    [data-theme="dark"] .markdown-content { color: var(--text-primary) !important; }
    [data-theme="dark"] .markdown-content p, [data-theme="dark"] .markdown-content li { color: var(--text-primary) !important; }
    [data-theme="dark"] .user-message-bubble,
    [data-theme="dark"] .user-message-bubble p,
    [data-theme="dark"] .user-message-bubble span,
    [data-theme="dark"] .user-message-bubble code,
    [data-theme="dark"] .user-message-bubble * { color: var(--text-primary) !important; }

    /* Mobile responsive */
    @media (max-width: 768px) {
        .sidebar-width { position: fixed; z-index: 50; height: 100%; }
        .sidebar-hidden { transform: translateX(-100%); }
        .sidebar-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 40; }
        .sidebar-overlay.hidden { display: none; }
        .user-edit-btn { left: -28px; }
    }
</style>
{% endblock %}

{% block content %}
<script>
    // Apply theme immediately before render to prevent flash
    (function() {
        const theme = localStorage.getItem('omlx-chat-theme') || 'light';
        document.documentElement.setAttribute('data-theme', theme);
    })();
</script>
<div class="h-screen flex overflow-hidden" x-data="chatApp()" x-init="init()">
    <!-- API Key Modal -->
    <div class="api-key-modal" :class="{ 'hidden': apiKeySet }" x-cloak>
        <div class="api-key-modal-content">
            <h2 class="text-xl font-bold mb-2">Enter API Key</h2>
            <p class="text-sm text-neutral-500 mb-4">Enter your oMLX API key to start chatting.</p>
            <input
                type="password"
                x-model="apiKeyInput"
                @keydown.enter="saveApiKey"
                placeholder="Enter API key..."
                class="w-full px-4 py-3 border border-neutral-200 rounded-xl mb-4 focus:outline-none focus:border-neutral-400"
                style="background: var(--bg-primary); color: var(--text-primary);"
            >
            <button @click="saveApiKey" class="btn-primary w-full" :disabled="!apiKeyInput.trim()">
                Continue
            </button>
        </div>
    </div>

    <!-- Sidebar Overlay (mobile) -->
    <div class="sidebar-overlay" :class="{ 'hidden': !sidebarOpen }" @click="sidebarOpen = false" x-cloak></div>

    <!-- Sidebar -->
    <div class="sidebar-width h-full bg-surface-primary border-r border-border-faint flex flex-col sidebar-transition"
         :class="{ 'sidebar-hidden': !sidebarOpen }">
        <!-- Sidebar Header -->
        <div class="p-4 border-b border-border-faint flex-shrink-0">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <img x-show="theme === 'light'" src="/admin/static/navbar-logo-light.svg" alt="oMLX" class="w-[30px] h-[30px]">
                    <img x-show="theme === 'dark'" src="/admin/static/navbar-logo-dark.svg" alt="oMLX" class="w-[30px] h-[30px]" x-cloak>
                    <span class="font-semibold">oMLX Chat</span>
                </div>
                <button @click="sidebarOpen = false" class="p-1.5 hover:bg-neutral-100 rounded-md" style="color: var(--text-primary);">
                    <i data-lucide="panel-left-close" class="w-4 h-4"></i>
                </button>
            </div>
        </div>

        <!-- New Chat Button -->
        <div class="p-3 flex-shrink-0">
            <button @click="startNewChat()" class="w-full flex items-center gap-2 px-3 py-2 bg-neutral-100 hover:bg-neutral-200 rounded-lg text-sm font-medium transition-colors" style="color: var(--text-primary);">
                <i data-lucide="plus" class="w-4 h-4"></i>
                New Chat
            </button>
        </div>

        <!-- Chat History -->
        <div class="flex-1 min-h-0 overflow-y-auto custom-scrollbar px-3">
            <template x-for="chat in chatHistory" :key="chat.id">
                <div @click="loadChat(chat.id)"
                     class="group flex items-center gap-2 px-3 py-2 rounded-lg cursor-pointer hover:bg-neutral-100 mb-1"
                     :class="{ 'bg-neutral-100': currentChatId === chat.id }">
                    <i data-lucide="message-square" class="w-4 h-4 flex-shrink-0" style="color: var(--text-muted);"></i>
                    <span class="text-sm truncate flex-1" style="color: var(--text-primary);" x-text="chat.title || 'New Chat'"></span>
                    <button @click.stop="deleteChat(chat.id)"
                            class="opacity-0 group-hover:opacity-100 p-1 hover:bg-red-100 rounded transition-opacity"
                            title="Delete chat">
                        <i data-lucide="trash-2" class="w-3 h-3 text-red-500"></i>
                    </button>
                </div>
            </template>
        </div>

        <!-- Sidebar Footer -->
        <div class="p-2 border-t border-border-faint space-y-0.5 flex-shrink-0">
            <a href="/admin/dashboard" class="flex items-center gap-1.5 px-2 py-1 text-xs text-neutral-500 hover:bg-neutral-100 rounded">
                <i data-lucide="settings" class="w-3 h-3"></i>
                Admin Settings
            </a>
            <button @click="toggleTheme()" class="w-full flex items-center gap-1.5 px-2 py-1 text-xs text-neutral-500 hover:bg-neutral-100 rounded">
                <i data-lucide="sun" class="w-3 h-3" x-show="theme === 'light'"></i>
                <i data-lucide="moon" class="w-3 h-3" x-show="theme === 'dark'" x-cloak></i>
                <span x-text="theme === 'light' ? 'Dark Mode' : 'Light Mode'"></span>
            </button>
            <button @click="clearAllHistory()" x-show="chatHistory.length > 0"
                    class="w-full flex items-center gap-1.5 px-2 py-1 text-xs text-red-500 hover:bg-red-50 rounded">
                <i data-lucide="trash-2" class="w-3 h-3"></i>
                Clear All History
            </button>
            <button @click="clearApiKey()" class="w-full flex items-center gap-1.5 px-2 py-1 text-xs text-neutral-500 hover:bg-neutral-100 rounded">
                <i data-lucide="key" class="w-3 h-3"></i>
                Change API Key
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col bg-surface-primary overflow-hidden">
        <!-- Header -->
        <header class="h-14 px-4 border-b border-border-faint flex items-center justify-between bg-surface-primary flex-shrink-0">
            <button @click="sidebarOpen = true" class="p-2 hover:bg-neutral-100 rounded-lg md:hidden" style="color: var(--text-primary);">
                <i data-lucide="menu" class="w-5 h-5"></i>
            </button>
            <button @click="sidebarOpen = !sidebarOpen" class="p-2 hover:bg-neutral-100 rounded-lg hidden md:block" style="color: var(--text-primary);">
                <i data-lucide="panel-left" class="w-5 h-5"></i>
            </button>

            <!-- Model Selector -->
            <div class="relative" x-data="{ open: false }">
                <button @click="open = !open" class="flex items-center gap-2 px-3 py-1.5 text-sm font-medium hover:bg-neutral-100 rounded-lg" style="color: var(--text-primary);">
                    <i data-lucide="cpu" class="w-4 h-4"></i>
                    <span x-text="currentModel || 'Select Model'"></span>
                    <i data-lucide="chevron-down" class="w-4 h-4"></i>
                </button>
                <div x-show="open" @click.away="open = false" x-cloak
                     class="absolute top-full mt-1 left-1/2 -translate-x-1/2 border border-neutral-200 rounded-lg shadow-lg py-1 min-w-[360px] max-w-[500px] max-h-60 overflow-y-auto z-50"
                     style="background: var(--bg-primary); border-color: var(--border-faint);">
                    <template x-for="model in availableModels" :key="model.id">
                        <button @click="selectModel(model.id); open = false"
                                class="w-full px-3 py-2 text-sm text-left hover:bg-neutral-100"
                                :class="{ 'bg-neutral-100': currentModel === model.id }"
                                style="color: var(--text-primary);">
                            <span x-text="model.id"></span>
                        </button>
                    </template>
                    <div x-show="availableModels.length === 0" class="px-3 py-2 text-sm" style="color: var(--text-tertiary);">
                        No models available
                    </div>
                </div>
            </div>

            <div class="w-10"></div>
        </header>

        <!-- Messages Area -->
        <div class="flex-1 min-h-0 overflow-y-auto custom-scrollbar" id="messagesContainer">
            <!-- Welcome Screen -->
            <div x-show="messages.length === 0" class="h-full flex items-center justify-center" x-cloak>
                <div class="text-center max-w-lg px-4">
                    <div class="flex items-center justify-center gap-3 mb-4">
                        <img x-show="theme === 'light'" src="/admin/static/logo-light.svg" alt="oMLX" class="w-[60px] h-[60px]">
                        <img x-show="theme === 'dark'" src="/admin/static/logo-dark.svg" alt="oMLX" class="w-[60px] h-[60px]" x-cloak>
                        <h1 class="text-2xl font-bold">Chat with oMLX</h1>
                    </div>
                    <p class="text-neutral-500 mb-6">Start a conversation with your local MLX models. Select a model above to begin.</p>
                    <div class="p-4 bg-neutral-50 rounded-xl text-sm text-neutral-600">
                        <i data-lucide="shield-check" class="w-4 h-4 inline mr-1"></i>
                        All conversations run locally on your device.
                    </div>
                </div>
            </div>

            <!-- Messages -->
            <div x-show="messages.length > 0" class="max-w-4xl mx-auto px-4 py-6 space-y-4">
                <template x-for="(msg, index) in messages" :key="index">
                    <div class="message-fade-in">
                        <!-- User Message -->
                        <div x-show="msg.role === 'user'" class="flex justify-end">
                            <div class="user-message">
                                <button @click="startEdit(index)" class="user-edit-btn" title="Edit message">
                                    <i data-lucide="pencil" class="w-4 h-4"></i>
                                </button>
                                <template x-if="editingIndex !== index">
                                    <div class="user-message-bubble" x-html="renderMarkdown(msg.content)"></div>
                                </template>
                                <template x-if="editingIndex === index">
                                    <div class="user-message-bubble" style="padding: 0; background: transparent;">
                                        <textarea
                                            x-model="editContent"
                                            @keydown.enter.ctrl="saveEdit(index)"
                                            @keydown.escape="cancelEdit"
                                            class="inline-edit-textarea"
                                            x-init="$nextTick(() => { $el.focus(); $el.setSelectionRange($el.value.length, $el.value.length); })"
                                        ></textarea>
                                        <div class="inline-edit-actions">
                                            <button @click="cancelEdit" class="px-3 py-1.5 text-sm border rounded-lg hover:bg-neutral-100" style="border-color: var(--border-normal); color: var(--text-secondary);">Cancel</button>
                                            <button @click="saveEdit(index)" class="px-3 py-1.5 text-sm bg-neutral-900 text-white rounded-lg hover:bg-neutral-800">Save & Resend</button>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>

                        <!-- Assistant Message -->
                        <div x-show="msg.role === 'assistant'" class="assistant-message">
                            <div class="message-header">
                                <div class="flex items-center gap-2 text-sm font-medium" style="color: var(--text-primary);">
                                    <i data-lucide="cpu" class="w-4 h-4" style="color: var(--text-tertiary);"></i>
                                    <span x-text="msg.model || currentModel || 'Assistant'"></span>
                                </div>
                                <div class="flex gap-1">
                                    <button @click="copyMessage(msg.content)" class="message-action-btn" title="Copy">
                                        <i data-lucide="copy" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="regenerateMessage(index)" class="message-action-btn" title="Regenerate">
                                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="message-body markdown-content" x-html="renderMarkdown(msg.content)"></div>
                        </div>
                    </div>
                </template>

                <!-- Streaming Message -->
                <div x-show="isStreaming" class="assistant-message message-fade-in">
                    <div class="message-header">
                        <div class="flex items-center gap-2 text-sm font-medium" style="color: var(--text-primary);">
                            <i data-lucide="cpu" class="w-4 h-4" style="color: var(--text-tertiary);"></i>
                            <span x-text="currentModel || 'Assistant'"></span>
                        </div>
                        <button @click="stopStreaming()" class="message-action-btn" title="Stop">
                            <i data-lucide="square" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <div class="message-body">
                        <!-- Loading dots - shown when no content yet -->
                        <div x-show="!streamingContent" class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                        <!-- Streaming content - shown when content exists -->
                        <div x-show="streamingContent" class="markdown-content" x-ref="streamingOutput" x-effect="updateStreamingDOM()"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Input Area -->
        <div class="p-4 border-t border-border-faint bg-surface-primary flex-shrink-0">
            <div class="max-w-4xl mx-auto">
                <div class="input-container flex items-end">
                    <textarea
                        x-model="inputMessage"
                        @keydown.enter="if (!$event.shiftKey) { $event.preventDefault(); sendMessage(); }"
                        @input="autoResize($event.target)"
                        placeholder="Type a message... (Shift+Enter for new line)"
                        :disabled="!apiKeySet || !currentModel || isStreaming"
                        rows="1"
                        class="flex-1 px-4 py-3 bg-transparent resize-none outline-none text-sm max-h-32"
                        style="color: var(--text-primary);"
                    ></textarea>
                    <button
                        @click="sendMessage()"
                        :disabled="!inputMessage.trim() || !apiKeySet || !currentModel || isStreaming"
                        class="w-10 h-10 m-1 bg-neutral-900 hover:bg-neutral-800 disabled:bg-neutral-300 rounded-full transition-colors flex items-center justify-center flex-shrink-0"
                    >
                        <i data-lucide="arrow-up" class="w-4 h-4 text-white"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Configure marked.js
    marked.use({
        breaks: true,
        gfm: true
    });

    if (typeof markedHighlight !== 'undefined') {
        marked.use(markedHighlight.markedHighlight({
            langPrefix: 'hljs language-',
            highlight(code, lang) {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                return hljs.highlight(code, { language }).value;
            }
        }));
    }

    function chatApp() {
        return {
            // API Key
            apiKeySet: false,
            apiKeyInput: '',

            // UI State
            sidebarOpen: window.innerWidth >= 768,
            theme: localStorage.getItem('omlx-chat-theme') || 'light',

            // Chat State
            currentChatId: null,
            chatHistory: [],
            messages: [],
            inputMessage: '',

            // Model State
            availableModels: [],
            currentModel: null,

            // Streaming State
            isStreaming: false,
            streamingContent: '',
            abortController: null,

            // Thinking streaming state
            thinkingState: {
                isInThinking: false,
                thinkingIndex: 0,
                thinkingContent: '',
                regularContent: '',
                thinkingStartTime: null
            },

            // Scroll state
            autoScrollEnabled: true,
            isUserScrolling: false,
            scrollTimeout: null,
            thinkingAutoScroll: true,
            thinkingScrollTimeout: null,
            thinkingScrollPosition: 0, // Save scroll position before DOM update

            // Edit State
            editingIndex: null,
            editContent: '',

            async init() {
                // Auto-inject API key from server (admin session already authenticated)
                const serverApiKey = {{ api_key | tojson }};
                if (serverApiKey) {
                    localStorage.setItem('omlx_chat_api_key', serverApiKey);
                }

                // Check for stored API key
                const storedKey = localStorage.getItem('omlx_chat_api_key');
                if (storedKey) {
                    this.apiKeySet = true;
                    await this.loadModels();
                    this.loadChatHistory();
                }

                // Apply theme
                this.applyTheme();

                // Watch messages array and reinitialize Lucide icons when it changes
                this.$watch('messages', () => {
                    this.$nextTick(() => lucide.createIcons());
                });

                // Watch chatHistory for sidebar icons
                this.$watch('chatHistory', () => {
                    this.$nextTick(() => lucide.createIcons());
                });

                // Setup scroll listener for auto-scroll management
                this.$nextTick(() => {
                    this.setupScrollListener();
                });
            },

            // Setup scroll listener for messages container
            setupScrollListener() {
                const container = document.getElementById('messagesContainer');
                if (!container) return;

                container.addEventListener('scroll', () => {
                    // Detect if user is manually scrolling
                    clearTimeout(this.scrollTimeout);
                    this.isUserScrolling = true;

                    // Check if at bottom (with threshold)
                    const threshold = 50;
                    const isAtBottom = container.scrollHeight - container.scrollTop - container.clientHeight <= threshold;

                    if (isAtBottom) {
                        // User scrolled to bottom, re-enable auto-scroll
                        this.autoScrollEnabled = true;
                    } else if (this.isStreaming) {
                        // User scrolled away from bottom during streaming, disable auto-scroll
                        this.autoScrollEnabled = false;
                    }

                    // Reset user scrolling flag after scroll ends
                    this.scrollTimeout = setTimeout(() => {
                        this.isUserScrolling = false;
                    }, 150);
                });
            },

            saveApiKey() {
                if (!this.apiKeyInput.trim()) return;
                localStorage.setItem('omlx_chat_api_key', this.apiKeyInput.trim());
                this.apiKeySet = true;
                this.apiKeyInput = '';
                this.loadModels();
                this.loadChatHistory();
            },

            clearApiKey() {
                if (confirm('Are you sure you want to change your API key?')) {
                    localStorage.removeItem('omlx_chat_api_key');
                    this.apiKeySet = false;
                    this.messages = [];
                    this.currentChatId = null;
                }
            },

            getApiKey() {
                return localStorage.getItem('omlx_chat_api_key') || '';
            },

            async loadModels() {
                try {
                    const response = await fetch('/v1/models', {
                        headers: {
                            'Authorization': `Bearer ${this.getApiKey()}`
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            alert('API key is incorrect. Please re-enter your API key.');
                            localStorage.removeItem('omlx_chat_api_key');
                            this.apiKeySet = false;
                            this.messages = [];
                            this.currentChatId = null;
                            return;
                        }
                        throw new Error('Failed to load models');
                    }

                    const data = await response.json();
                    this.availableModels = data.data || [];

                    // Auto-select first model if none selected
                    if (!this.currentModel && this.availableModels.length > 0) {
                        this.currentModel = this.availableModels[0].id;
                    }
                } catch (error) {
                    console.error('Error loading models:', error);
                }
            },

            selectModel(modelId) {
                this.currentModel = modelId;
            },

            loadChatHistory() {
                const history = localStorage.getItem('omlx_chat_history');
                if (history) {
                    try {
                        this.chatHistory = JSON.parse(history);
                    } catch (e) {
                        this.chatHistory = [];
                    }
                }
            },

            saveChatHistory() {
                localStorage.setItem('omlx_chat_history', JSON.stringify(this.chatHistory));
            },

            startNewChat() {
                this.currentChatId = 'chat_' + Date.now();
                this.messages = [];
                this.sidebarOpen = window.innerWidth >= 768;
            },

            loadChat(chatId) {
                const chat = this.chatHistory.find(c => c.id === chatId);
                if (chat) {
                    this.currentChatId = chatId;
                    this.messages = chat.messages || [];
                    if (chat.model) {
                        this.currentModel = chat.model;
                    }
                }
                this.sidebarOpen = window.innerWidth >= 768;
            },

            saveCurrentChat() {
                if (!this.currentChatId || this.messages.length === 0) return;

                const existingIndex = this.chatHistory.findIndex(c => c.id === this.currentChatId);
                const chatData = {
                    id: this.currentChatId,
                    title: this.messages[0]?.content?.slice(0, 50) || 'New Chat',
                    messages: this.messages,
                    model: this.currentModel,
                    updatedAt: new Date().toISOString()
                };

                if (existingIndex >= 0) {
                    this.chatHistory[existingIndex] = chatData;
                } else {
                    this.chatHistory.unshift(chatData);
                }

                // Keep only last 50 chats
                this.chatHistory = this.chatHistory.slice(0, 50);
                this.saveChatHistory();
            },

            async sendMessage() {
                if (!this.inputMessage.trim() || !this.currentModel || this.isStreaming) return;

                const userMessage = this.inputMessage.trim();
                this.inputMessage = '';

                // Create new chat if needed
                if (!this.currentChatId) {
                    this.currentChatId = 'chat_' + Date.now();
                }

                // Add user message
                this.messages.push({
                    role: 'user',
                    content: userMessage
                });

                // Force scroll to bottom when sending message
                this.forceScrollToBottom();

                // Start streaming
                await this.streamResponse();
            },

            async streamResponse() {
                this.isStreaming = true;
                this.streamingContent = '';
                this.abortController = new AbortController();
                this.autoScrollEnabled = true; // Enable auto-scroll at start of streaming

                try {
                    const response = await fetch('/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.getApiKey()}`
                        },
                        body: JSON.stringify({
                            model: this.currentModel,
                            messages: this.messages,
                            stream: true
                        }),
                        signal: this.abortController.signal
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText || `Error: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;

                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    if (data.choices?.[0]?.delta?.content) {
                                        this.streamingContent += data.choices[0].delta.content;
                                        this.scrollToBottom();
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE:', e);
                                }
                            }
                        }
                    }

                    // Add completed message
                    if (this.streamingContent) {
                        this.messages.push({
                            role: 'assistant',
                            content: this.streamingContent,
                            model: this.currentModel
                        });
                        this.saveCurrentChat();
                    }

                } catch (error) {
                    console.log('[streamResponse] catch error:', error.name, error.message);
                    if (error.name === 'AbortError') {
                        console.log('[streamResponse] AbortError caught - stream stopped by user');
                        // Stream was stopped by user
                        if (this.streamingContent) {
                            this.messages.push({
                                role: 'assistant',
                                content: this.streamingContent,
                                model: this.currentModel
                            });
                            this.saveCurrentChat();
                        }
                    } else {
                        console.error('Streaming error:', error);
                        this.messages.push({
                            role: 'assistant',
                            content: `Error: ${error.message}`,
                            model: this.currentModel
                        });
                    }
                } finally {
                    this.isStreaming = false;
                    this.streamingContent = '';
                    this.abortController = null;
                    this.thinkingAutoScroll = true; // Reset thinking scroll state
                    this.$nextTick(() => lucide.createIcons());
                }
            },

            stopStreaming() {
                console.log('[stopStreaming] called, abortController:', this.abortController);
                if (this.abortController) {
                    console.log('[stopStreaming] calling abort()');
                    this.abortController.abort();
                    console.log('[stopStreaming] abort() called');
                } else {
                    console.log('[stopStreaming] abortController is null');
                }
            },

            async regenerateMessage(index) {
                if (this.isStreaming) return;

                // Find the user message before this assistant message
                const messagesToKeep = this.messages.slice(0, index);
                this.messages = messagesToKeep;

                await this.streamResponse();
            },

            copyMessage(content) {
                navigator.clipboard.writeText(content).then(() => {
                    // Visual feedback could be added here
                }).catch(err => {
                    console.error('Failed to copy:', err);
                });
            },

            // Edit functions
            startEdit(index) {
                if (this.isStreaming || this.editingIndex !== null) return;
                this.editingIndex = index;
                this.editContent = this.messages[index].content;
                this.$nextTick(() => lucide.createIcons());
            },

            cancelEdit() {
                this.editingIndex = null;
                this.editContent = '';
                this.$nextTick(() => lucide.createIcons());
            },

            async saveEdit(index) {
                if (!this.editContent.trim() || this.isStreaming) return;

                const newContent = this.editContent.trim();

                // Remove all messages from this index onwards
                this.messages = this.messages.slice(0, index);

                // Add edited user message
                this.messages.push({
                    role: 'user',
                    content: newContent
                });

                // Reset edit state
                this.editingIndex = null;
                this.editContent = '';

                // Scroll and get new response
                this.scrollToBottom();
                await this.streamResponse();
            },

            // Delete chat
            deleteChat(chatId) {
                if (!confirm('Are you sure you want to delete this chat?')) return;

                this.chatHistory = this.chatHistory.filter(c => c.id !== chatId);
                this.saveChatHistory();

                // If deleted current chat, start new
                if (this.currentChatId === chatId) {
                    this.startNewChat();
                }

                this.$nextTick(() => lucide.createIcons());
            },

            // Clear all history
            clearAllHistory() {
                if (!confirm('Are you sure you want to delete ALL chat history? This cannot be undone.')) return;

                this.chatHistory = [];
                this.saveChatHistory();
                this.startNewChat();

                this.$nextTick(() => lucide.createIcons());
            },

            // Thinking/Reasoning tag processing
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            extractThinking(text) {
                const thinkingRegex = /<think>([\s\S]*?)<\/think>/g;
                const thinkingBlocks = [];
                let cleanText = text;
                let match;

                while ((match = thinkingRegex.exec(text)) !== null) {
                    thinkingBlocks.push({
                        content: match[1].trim(),
                        placeholder: `THINKINGPLACEHOLDER${thinkingBlocks.length}`
                    });
                }

                // Remove thinking tags from the main text
                cleanText = text.replace(thinkingRegex, '').trim();

                return { thinkingBlocks, cleanText };
            },

            renderThinkingBlock(content, index, messageId) {
                // Estimate thinking time based on content length
                const wordsPerSecond = 3;
                const wordCount = content.split(/\s+/).length;
                const thinkingTime = Math.max(1, Math.round(wordCount / wordsPerSecond));

                const uniqueId = `${messageId || Date.now()}_${index}`;

                return `
                    <div class="thinking-container">
                        <div class="thinking-header" onclick="document.getElementById('thinking-content-${uniqueId}').classList.toggle('collapsed'); document.getElementById('thinking-toggle-${uniqueId}').classList.toggle('collapsed');">
                            <svg class="thinking-icon" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="10" cy="10" r="9" stroke="currentColor" stroke-width="1.5"/>
                                <path d="M10 6v4l2.5 2.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                            <span class="thinking-text">Thought for ${thinkingTime} seconds</span>
                            <svg class="thinking-toggle" id="thinking-toggle-${uniqueId}" viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M1 1l4 4 4-4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </div>
                        <div class="thinking-content collapsed" id="thinking-content-${uniqueId}">
                            ${this.escapeHtml(content).replace(/\n/g, '<br>')}
                        </div>
                    </div>
                `;
            },

            renderMarkdown(text) {
                if (!text) return '';
                try {
                    // Extract thinking blocks first
                    const { thinkingBlocks, cleanText } = this.extractThinking(text);

                    // Parse clean text with marked
                    let html = marked.parse(cleanText);

                    // Add thinking blocks at the beginning if they exist
                    if (thinkingBlocks.length > 0) {
                        const messageTimestamp = Date.now();
                        const thinkingHtml = thinkingBlocks.map((block, index) =>
                            this.renderThinkingBlock(block.content, index, messageTimestamp)
                        ).join('');
                        html = thinkingHtml + html;
                    }

                    // Schedule code copy buttons and math rendering after DOM update
                    this.$nextTick(() => {
                        this.addCodeCopyButtons();
                        this.renderMath();
                    });
                    return html;
                } catch (e) {
                    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                }
            },

            // Render markdown for streaming content (pure HTML generator, no side effects)
            renderStreamingMarkdown(text) {
                if (!text) return '';

                try {
                    let html = '';
                    let remaining = text;

                    // Process complete think blocks first
                    const completeThinkRegex = /<think>([\s\S]*?)<\/think>/g;
                    let lastIndex = 0;
                    let match;
                    let blockIndex = 0;

                    while ((match = completeThinkRegex.exec(text)) !== null) {
                        const beforeContent = text.substring(lastIndex, match.index);
                        if (beforeContent.trim()) {
                            html += marked.parse(beforeContent);
                        }
                        html += this.renderThinkingBlock(match[1].trim(), blockIndex++, 'streaming');
                        lastIndex = match.index + match[0].length;
                    }

                    remaining = text.substring(lastIndex);

                    const incompleteThinkIndex = remaining.indexOf('<think>');
                    if (incompleteThinkIndex !== -1) {
                        const beforeIncomplete = remaining.substring(0, incompleteThinkIndex);
                        if (beforeIncomplete.trim()) {
                            html += marked.parse(beforeIncomplete);
                        }

                        const thinkingContent = remaining.substring(incompleteThinkIndex + 7);

                        html += `
                            <div class="thinking-container" id="streaming-thinking-container">
                                <div class="thinking-header" onclick="this.parentElement.querySelector('.thinking-content').classList.toggle('collapsed');">
                                    <svg class="thinking-icon" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <circle cx="10" cy="10" r="9" stroke="currentColor" stroke-width="1.5"/>
                                        <path d="M10 6v4l2.5 2.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                    </svg>
                                    <span class="thinking-text">Thinking...</span>
                                </div>
                                <div class="thinking-content" id="streaming-thinking-content">
                                    ${this.escapeHtml(thinkingContent).replace(/\n/g, '<br>')}
                                </div>
                            </div>
                        `;
                    } else if (remaining.trim()) {
                        html += marked.parse(remaining);
                    }

                    return html;
                } catch (e) {
                    return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                }
            },

            // Efficiently update streaming DOM without destroying thinking container
            updateStreamingDOM() {
                const container = this.$refs.streamingOutput;
                if (!container) return;

                if (!this.streamingContent) {
                    container.innerHTML = '';
                    return;
                }

                const text = this.streamingContent;

                // Detect if we're in an incomplete think block
                const lastOpenThink = text.lastIndexOf('<think>');
                const lastCloseThink = text.lastIndexOf('</think>');
                const isInIncompleteThink = lastOpenThink !== -1 && lastCloseThink < lastOpenThink;

                // Fast path: thinking container already exists, just update its text
                if (isInIncompleteThink) {
                    const existingEl = container.querySelector('#streaming-thinking-content');
                    if (existingEl) {
                        const thinkingText = text.substring(lastOpenThink + 7);
                        existingEl.innerHTML = this.escapeHtml(thinkingText).replace(/\n/g, '<br>');
                        this.scrollThinkingContent();
                        this.scrollToBottom();
                        return;
                    }
                }

                // Full render path (first render or structural change)
                container.innerHTML = this.renderStreamingMarkdown(text);

                this.$nextTick(() => {
                    this.addCodeCopyButtons();
                    this.renderMath();
                    if (isInIncompleteThink) {
                        this.scrollThinkingContent();
                    }
                    this.scrollToBottom();
                });
            },

            addCodeCopyButtons() {
                const container = document.getElementById('messagesContainer');
                if (!container) return;

                const codeBlocks = container.querySelectorAll('pre code');
                codeBlocks.forEach(codeBlock => {
                    const pre = codeBlock.parentElement;

                    // Wrap in container if not already
                    if (!pre.parentElement.classList.contains('code-block-wrapper')) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'code-block-wrapper';
                        pre.parentElement.insertBefore(wrapper, pre);
                        wrapper.appendChild(pre);
                    }

                    // Check if button already exists
                    if (pre.parentElement.querySelector('.code-copy-btn')) return;

                    // Create copy button
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'code-copy-btn';
                    copyBtn.textContent = 'Copy';
                    copyBtn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        navigator.clipboard.writeText(codeBlock.textContent).then(() => {
                            copyBtn.textContent = 'Copied!';
                            setTimeout(() => copyBtn.textContent = 'Copy', 2000);
                        });
                    };
                    pre.parentElement.appendChild(copyBtn);
                });
            },

            renderMath() {
                if (typeof renderMathInElement === 'undefined') {
                    setTimeout(() => this.renderMath(), 100);
                    return;
                }

                const container = document.getElementById('messagesContainer');
                if (!container) return;

                try {
                    renderMathInElement(container, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false,
                        strict: false,
                        ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
                        ignoredClasses: ['hljs']
                    });
                } catch (e) {
                    console.error('Math rendering error:', e);
                }
            },

            // Check if scroll is at bottom
            isAtBottom() {
                const container = document.getElementById('messagesContainer');
                if (!container) return true;
                const threshold = 50;
                return container.scrollHeight - container.scrollTop - container.clientHeight <= threshold;
            },

            // Scroll to bottom (respects autoScrollEnabled unless forced)
            scrollToBottom(force = false) {
                this.$nextTick(() => {
                    const container = document.getElementById('messagesContainer');
                    if (!container) return;

                    // Only scroll if auto-scroll is enabled or forced
                    if (!force && !this.autoScrollEnabled) return;

                    container.scrollTo({
                        top: container.scrollHeight,
                        behavior: force ? 'auto' : 'smooth'
                    });
                });
            },

            // Force scroll to bottom and re-enable auto-scroll
            forceScrollToBottom() {
                this.autoScrollEnabled = true;
                this.scrollToBottom(true);
            },

            // Scroll thinking content (respects thinkingAutoScroll, restores position if needed)
            scrollThinkingContent() {
                const thinkingContent = document.getElementById('streaming-thinking-content');
                if (!thinkingContent) return;

                // Setup scroll listener if not already done
                if (!thinkingContent.hasAttribute('data-scroll-listener')) {
                    thinkingContent.setAttribute('data-scroll-listener', 'true');
                    this.setupThinkingScrollListener(thinkingContent);
                }

                if (this.thinkingAutoScroll) {
                    // Auto-scroll to bottom
                    thinkingContent.scrollTop = thinkingContent.scrollHeight;
                } else {
                    // Restore saved scroll position
                    thinkingContent.scrollTop = this.thinkingScrollPosition;
                }
            },

            // Setup scroll listener for thinking content
            setupThinkingScrollListener(element) {
                element.addEventListener('scroll', () => {
                    clearTimeout(this.thinkingScrollTimeout);

                    // Save current scroll position
                    this.thinkingScrollPosition = element.scrollTop;

                    // Check if at bottom
                    const threshold = 30;
                    const isAtBottom = element.scrollHeight - element.scrollTop - element.clientHeight <= threshold;

                    if (isAtBottom) {
                        this.thinkingAutoScroll = true;
                    } else {
                        this.thinkingAutoScroll = false;
                    }

                    this.thinkingScrollTimeout = setTimeout(() => {
                        // Scroll ended
                    }, 150);
                });
            },

            autoResize(el) {
                el.style.height = 'auto';
                el.style.height = Math.min(el.scrollHeight, 128) + 'px';
            },

            toggleTheme() {
                this.theme = this.theme === 'light' ? 'dark' : 'light';
                localStorage.setItem('omlx-chat-theme', this.theme);
                this.applyTheme();
                this.$nextTick(() => lucide.createIcons());
            },

            applyTheme() {
                document.documentElement.setAttribute('data-theme', this.theme);

                const lightTheme = document.getElementById('hljs-light-theme');
                const darkTheme = document.getElementById('hljs-dark-theme');

                if (lightTheme && darkTheme) {
                    lightTheme.disabled = this.theme === 'dark';
                    darkTheme.disabled = this.theme === 'light';
                }
            }
        };
    }
</script>
{% endblock %}
